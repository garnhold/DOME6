//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:/Users/Garrett/Documents/Visual Studio 2013/Projects/DOME6Grammar\DOME.g4 by ANTLR 4.5.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.1")]
[System.CLSCompliant(false)]
public partial class DOMEParser : Parser {
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, 
		T__9=10, T__10=11, T__11=12, T__12=13, T__13=14, T__14=15, T__15=16, T__16=17, 
		T__17=18, T__18=19, T__19=20, T__20=21, T__21=22, LITERAL_STRING=23, LITERAL_CLASS=24, 
		RULE_ID=25, TOKEN_ID=26, WHITESPACE=27;
	public const int
		RULE_grammarDefinition = 0, RULE_definition = 1, RULE_id = 2, RULE_grammarHeader = 3, 
		RULE_importHeader = 4, RULE_grammarType = 5, RULE_info = 6, RULE_quantifier = 7, 
		RULE_ruleReference = 8, RULE_ruleDefinitionConcreteDirect = 9, RULE_ruleDefinitionConcreteInherited = 10, 
		RULE_ruleDefinitionAbstract = 11, RULE_ruleAtom = 12, RULE_ruleExpression = 13, 
		RULE_settings = 14, RULE_setting = 15, RULE_tokenReference = 16, RULE_tokenDefinition = 17, 
		RULE_tokenAtom = 18;
	public static readonly string[] ruleNames = {
		"grammarDefinition", "definition", "id", "grammarHeader", "importHeader", 
		"grammarType", "info", "quantifier", "ruleReference", "ruleDefinitionConcreteDirect", 
		"ruleDefinitionConcreteInherited", "ruleDefinitionAbstract", "ruleAtom", 
		"ruleExpression", "settings", "setting", "tokenReference", "tokenDefinition", 
		"tokenAtom"
	};

	private static readonly string[] _LiteralNames = {
		null, "'@'", "'grammar'", "';'", "'import'", "','", "'parser'", "'lexer'", 
		"'/*info:'", "'*/'", "'?'", "'*'", "'+'", "':'", "'#'", "'|'", "'('", 
		"')'", "'/*group:{*/'", "'/*group:}*/'", "'=>'", "'->'", "'.'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, "LITERAL_STRING", 
		"LITERAL_CLASS", "RULE_ID", "TOKEN_ID", "WHITESPACE"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "DOME.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public DOMEParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class GrammarDefinitionContext : ParserRuleContext {
		public GrammarHeaderContext grammarHeader() {
			return GetRuleContext<GrammarHeaderContext>(0);
		}
		public ImportHeaderContext importHeader() {
			return GetRuleContext<ImportHeaderContext>(0);
		}
		public DefinitionContext[] definition() {
			return GetRuleContexts<DefinitionContext>();
		}
		public DefinitionContext definition(int i) {
			return GetRuleContext<DefinitionContext>(i);
		}
		public GrammarDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grammarDefinition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrammarDefinition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GrammarDefinitionContext grammarDefinition() {
		GrammarDefinitionContext _localctx = new GrammarDefinitionContext(Context, State);
		EnterRule(_localctx, 0, RULE_grammarDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 38; grammarHeader();
			State = 40;
			_la = TokenStream.La(1);
			if (_la==T__3) {
				{
				State = 39; importHeader();
				}
			}

			State = 45;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__15) | (1L << T__17) | (1L << LITERAL_STRING) | (1L << RULE_ID) | (1L << TOKEN_ID))) != 0)) {
				{
				{
				State = 42; definition();
				}
				}
				State = 47;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefinitionContext : ParserRuleContext {
		public DefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_definition; } }
	 
		public DefinitionContext() { }
		public virtual void CopyFrom(DefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Definition_RuleDefinition_ConcreteInheritedContext : DefinitionContext {
		public RuleDefinitionConcreteInheritedContext ruleDefinitionConcreteInherited() {
			return GetRuleContext<RuleDefinitionConcreteInheritedContext>(0);
		}
		public Definition_RuleDefinition_ConcreteInheritedContext(DefinitionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefinition_RuleDefinition_ConcreteInherited(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Definition_TokenDefinitionContext : DefinitionContext {
		public TokenDefinitionContext tokenDefinition() {
			return GetRuleContext<TokenDefinitionContext>(0);
		}
		public Definition_TokenDefinitionContext(DefinitionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefinition_TokenDefinition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Definition_RuleDefinition_ConcreteDirectContext : DefinitionContext {
		public RuleDefinitionConcreteDirectContext ruleDefinitionConcreteDirect() {
			return GetRuleContext<RuleDefinitionConcreteDirectContext>(0);
		}
		public Definition_RuleDefinition_ConcreteDirectContext(DefinitionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefinition_RuleDefinition_ConcreteDirect(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Definition_RuleDefinition_AbstractContext : DefinitionContext {
		public RuleDefinitionAbstractContext ruleDefinitionAbstract() {
			return GetRuleContext<RuleDefinitionAbstractContext>(0);
		}
		public Definition_RuleDefinition_AbstractContext(DefinitionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefinition_RuleDefinition_Abstract(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefinitionContext definition() {
		DefinitionContext _localctx = new DefinitionContext(Context, State);
		EnterRule(_localctx, 2, RULE_definition);
		try {
			State = 52;
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				_localctx = new Definition_RuleDefinition_ConcreteDirectContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 48; ruleDefinitionConcreteDirect();
				}
				break;
			case 2:
				_localctx = new Definition_RuleDefinition_ConcreteInheritedContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 49; ruleDefinitionConcreteInherited();
				}
				break;
			case 3:
				_localctx = new Definition_RuleDefinition_AbstractContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 50; ruleDefinitionAbstract();
				}
				break;
			case 4:
				_localctx = new Definition_TokenDefinitionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 51; tokenDefinition();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdContext : ParserRuleContext {
		public ITerminalNode RULE_ID() { return GetToken(DOMEParser.RULE_ID, 0); }
		public ITerminalNode TOKEN_ID() { return GetToken(DOMEParser.TOKEN_ID, 0); }
		public IdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitId(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdContext id() {
		IdContext _localctx = new IdContext(Context, State);
		EnterRule(_localctx, 4, RULE_id);
		int _la;
		try {
			State = 59;
			switch (TokenStream.La(1)) {
			case T__0:
			case RULE_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 55;
				_la = TokenStream.La(1);
				if (_la==T__0) {
					{
					State = 54; Match(T__0);
					}
				}

				State = 57; Match(RULE_ID);
				}
				break;
			case TOKEN_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 58; Match(TOKEN_ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GrammarHeaderContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public GrammarTypeContext grammarType() {
			return GetRuleContext<GrammarTypeContext>(0);
		}
		public GrammarHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grammarHeader; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrammarHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GrammarHeaderContext grammarHeader() {
		GrammarHeaderContext _localctx = new GrammarHeaderContext(Context, State);
		EnterRule(_localctx, 6, RULE_grammarHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 62;
			_la = TokenStream.La(1);
			if (_la==T__5 || _la==T__6) {
				{
				State = 61; grammarType();
				}
			}

			State = 64; Match(T__1);
			State = 65; id();
			State = 66; Match(T__2);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImportHeaderContext : ParserRuleContext {
		public IdContext[] id() {
			return GetRuleContexts<IdContext>();
		}
		public IdContext id(int i) {
			return GetRuleContext<IdContext>(i);
		}
		public ImportHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_importHeader; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImportHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ImportHeaderContext importHeader() {
		ImportHeaderContext _localctx = new ImportHeaderContext(Context, State);
		EnterRule(_localctx, 8, RULE_importHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 68; Match(T__3);
			State = 69; id();
			State = 74;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==T__4) {
				{
				{
				State = 70; Match(T__4);
				State = 71; id();
				}
				}
				State = 76;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 77; Match(T__2);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GrammarTypeContext : ParserRuleContext {
		public GrammarTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grammarType; } }
	 
		public GrammarTypeContext() { }
		public virtual void CopyFrom(GrammarTypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class GrammarTypeLexerContext : GrammarTypeContext {
		public GrammarTypeLexerContext(GrammarTypeContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrammarTypeLexer(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class GrammarTypeParserContext : GrammarTypeContext {
		public GrammarTypeParserContext(GrammarTypeContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrammarTypeParser(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GrammarTypeContext grammarType() {
		GrammarTypeContext _localctx = new GrammarTypeContext(Context, State);
		EnterRule(_localctx, 10, RULE_grammarType);
		try {
			State = 81;
			switch (TokenStream.La(1)) {
			case T__5:
				_localctx = new GrammarTypeParserContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 79; Match(T__5);
				}
				break;
			case T__6:
				_localctx = new GrammarTypeLexerContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 80; Match(T__6);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InfoContext : ParserRuleContext {
		public SettingsContext settings() {
			return GetRuleContext<SettingsContext>(0);
		}
		public InfoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_info; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInfo(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InfoContext info() {
		InfoContext _localctx = new InfoContext(Context, State);
		EnterRule(_localctx, 12, RULE_info);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 83; Match(T__7);
			State = 84; settings();
			State = 85; Match(T__8);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QuantifierContext : ParserRuleContext {
		public QuantifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quantifier; } }
	 
		public QuantifierContext() { }
		public virtual void CopyFrom(QuantifierContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class QuantifierNoneOrOneContext : QuantifierContext {
		public QuantifierNoneOrOneContext(QuantifierContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuantifierNoneOrOne(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class QuantifierNoneOrMoreContext : QuantifierContext {
		public QuantifierNoneOrMoreContext(QuantifierContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuantifierNoneOrMore(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class QuantifierOneOrMoreContext : QuantifierContext {
		public QuantifierOneOrMoreContext(QuantifierContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuantifierOneOrMore(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QuantifierContext quantifier() {
		QuantifierContext _localctx = new QuantifierContext(Context, State);
		EnterRule(_localctx, 14, RULE_quantifier);
		try {
			State = 96;
			switch (TokenStream.La(1)) {
			case T__9:
				_localctx = new QuantifierNoneOrOneContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 87; Match(T__9);
				}
				break;
			case T__10:
				_localctx = new QuantifierNoneOrMoreContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 88; Match(T__10);
				State = 90;
				switch ( Interpreter.AdaptivePredict(TokenStream,8,Context) ) {
				case 1:
					{
					State = 89; Match(T__9);
					}
					break;
				}
				}
				break;
			case T__11:
				_localctx = new QuantifierOneOrMoreContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 92; Match(T__11);
				State = 94;
				switch ( Interpreter.AdaptivePredict(TokenStream,9,Context) ) {
				case 1:
					{
					State = 93; Match(T__9);
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RuleReferenceContext : ParserRuleContext {
		public ITerminalNode RULE_ID() { return GetToken(DOMEParser.RULE_ID, 0); }
		public RuleReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ruleReference; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RuleReferenceContext ruleReference() {
		RuleReferenceContext _localctx = new RuleReferenceContext(Context, State);
		EnterRule(_localctx, 16, RULE_ruleReference);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 98; Match(RULE_ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RuleDefinitionConcreteDirectContext : ParserRuleContext {
		public ITerminalNode RULE_ID() { return GetToken(DOMEParser.RULE_ID, 0); }
		public RuleExpressionContext ruleExpression() {
			return GetRuleContext<RuleExpressionContext>(0);
		}
		public InfoContext info() {
			return GetRuleContext<InfoContext>(0);
		}
		public RuleDefinitionConcreteDirectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ruleDefinitionConcreteDirect; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleDefinitionConcreteDirect(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RuleDefinitionConcreteDirectContext ruleDefinitionConcreteDirect() {
		RuleDefinitionConcreteDirectContext _localctx = new RuleDefinitionConcreteDirectContext(Context, State);
		EnterRule(_localctx, 18, RULE_ruleDefinitionConcreteDirect);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 100; Match(RULE_ID);
			State = 102;
			_la = TokenStream.La(1);
			if (_la==T__7) {
				{
				State = 101; info();
				}
			}

			State = 104; Match(T__12);
			State = 105; ruleExpression(0);
			State = 106; Match(T__2);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RuleDefinitionConcreteInheritedContext : ParserRuleContext {
		public RuleExpressionContext ruleExpression() {
			return GetRuleContext<RuleExpressionContext>(0);
		}
		public ITerminalNode RULE_ID() { return GetToken(DOMEParser.RULE_ID, 0); }
		public InfoContext info() {
			return GetRuleContext<InfoContext>(0);
		}
		public RuleDefinitionConcreteInheritedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ruleDefinitionConcreteInherited; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleDefinitionConcreteInherited(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RuleDefinitionConcreteInheritedContext ruleDefinitionConcreteInherited() {
		RuleDefinitionConcreteInheritedContext _localctx = new RuleDefinitionConcreteInheritedContext(Context, State);
		EnterRule(_localctx, 20, RULE_ruleDefinitionConcreteInherited);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 108; ruleExpression(0);
			State = 109; Match(T__13);
			State = 110; Match(RULE_ID);
			State = 112;
			_la = TokenStream.La(1);
			if (_la==T__7) {
				{
				State = 111; info();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RuleDefinitionAbstractContext : ParserRuleContext {
		public ITerminalNode RULE_ID() { return GetToken(DOMEParser.RULE_ID, 0); }
		public RuleDefinitionConcreteInheritedContext[] ruleDefinitionConcreteInherited() {
			return GetRuleContexts<RuleDefinitionConcreteInheritedContext>();
		}
		public RuleDefinitionConcreteInheritedContext ruleDefinitionConcreteInherited(int i) {
			return GetRuleContext<RuleDefinitionConcreteInheritedContext>(i);
		}
		public InfoContext info() {
			return GetRuleContext<InfoContext>(0);
		}
		public RuleDefinitionAbstractContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ruleDefinitionAbstract; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleDefinitionAbstract(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RuleDefinitionAbstractContext ruleDefinitionAbstract() {
		RuleDefinitionAbstractContext _localctx = new RuleDefinitionAbstractContext(Context, State);
		EnterRule(_localctx, 22, RULE_ruleDefinitionAbstract);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 114; Match(RULE_ID);
			State = 116;
			_la = TokenStream.La(1);
			if (_la==T__7) {
				{
				State = 115; info();
				}
			}

			State = 118; Match(T__12);
			State = 119; ruleDefinitionConcreteInherited();
			State = 124;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==T__14) {
				{
				{
				State = 120; Match(T__14);
				State = 121; ruleDefinitionConcreteInherited();
				}
				}
				State = 126;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 127; Match(T__2);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RuleAtomContext : ParserRuleContext {
		public RuleAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ruleAtom; } }
	 
		public RuleAtomContext() { }
		public virtual void CopyFrom(RuleAtomContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class RuleAtomTokenReferenceContext : RuleAtomContext {
		public TokenReferenceContext tokenReference() {
			return GetRuleContext<TokenReferenceContext>(0);
		}
		public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public InfoContext info() {
			return GetRuleContext<InfoContext>(0);
		}
		public RuleAtomTokenReferenceContext(RuleAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleAtomTokenReference(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RuleAtomRuleReferenceContext : RuleAtomContext {
		public RuleReferenceContext ruleReference() {
			return GetRuleContext<RuleReferenceContext>(0);
		}
		public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public InfoContext info() {
			return GetRuleContext<InfoContext>(0);
		}
		public RuleAtomRuleReferenceContext(RuleAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleAtomRuleReference(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RuleAtomGroupContext : RuleAtomContext {
		public RuleExpressionContext ruleExpression() {
			return GetRuleContext<RuleExpressionContext>(0);
		}
		public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public RuleAtomGroupContext(RuleAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleAtomGroup(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RuleAtomLiteralContext : RuleAtomContext {
		public ITerminalNode LITERAL_STRING() { return GetToken(DOMEParser.LITERAL_STRING, 0); }
		public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public RuleAtomLiteralContext(RuleAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleAtomLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RuleAtomInfoGroupContext : RuleAtomContext {
		public RuleExpressionContext ruleExpression() {
			return GetRuleContext<RuleExpressionContext>(0);
		}
		public InfoContext info() {
			return GetRuleContext<InfoContext>(0);
		}
		public RuleAtomInfoGroupContext(RuleAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleAtomInfoGroup(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RuleAtomContext ruleAtom() {
		RuleAtomContext _localctx = new RuleAtomContext(Context, State);
		EnterRule(_localctx, 24, RULE_ruleAtom);
		try {
			State = 159;
			switch (TokenStream.La(1)) {
			case LITERAL_STRING:
				_localctx = new RuleAtomLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 129; Match(LITERAL_STRING);
				State = 131;
				switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
				case 1:
					{
					State = 130; quantifier();
					}
					break;
				}
				}
				break;
			case TOKEN_ID:
				_localctx = new RuleAtomTokenReferenceContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 133; tokenReference();
				State = 135;
				switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
				case 1:
					{
					State = 134; quantifier();
					}
					break;
				}
				State = 138;
				switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
				case 1:
					{
					State = 137; info();
					}
					break;
				}
				}
				break;
			case RULE_ID:
				_localctx = new RuleAtomRuleReferenceContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 140; ruleReference();
				State = 142;
				switch ( Interpreter.AdaptivePredict(TokenStream,18,Context) ) {
				case 1:
					{
					State = 141; quantifier();
					}
					break;
				}
				State = 145;
				switch ( Interpreter.AdaptivePredict(TokenStream,19,Context) ) {
				case 1:
					{
					State = 144; info();
					}
					break;
				}
				}
				break;
			case T__15:
				_localctx = new RuleAtomGroupContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 147; Match(T__15);
				State = 148; ruleExpression(0);
				State = 149; Match(T__16);
				State = 151;
				switch ( Interpreter.AdaptivePredict(TokenStream,20,Context) ) {
				case 1:
					{
					State = 150; quantifier();
					}
					break;
				}
				}
				break;
			case T__17:
				_localctx = new RuleAtomInfoGroupContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 153; Match(T__17);
				State = 154; ruleExpression(0);
				State = 155; Match(T__18);
				State = 157;
				switch ( Interpreter.AdaptivePredict(TokenStream,21,Context) ) {
				case 1:
					{
					State = 156; info();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RuleExpressionContext : ParserRuleContext {
		public RuleExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ruleExpression; } }
	 
		public RuleExpressionContext() { }
		public virtual void CopyFrom(RuleExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class RuleExpression_SequenceContext : RuleExpressionContext {
		public RuleAtomContext[] ruleAtom() {
			return GetRuleContexts<RuleAtomContext>();
		}
		public RuleAtomContext ruleAtom(int i) {
			return GetRuleContext<RuleAtomContext>(i);
		}
		public RuleExpression_SequenceContext(RuleExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleExpression_Sequence(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RuleExpression_AlternativesContext : RuleExpressionContext {
		public RuleExpressionContext[] ruleExpression() {
			return GetRuleContexts<RuleExpressionContext>();
		}
		public RuleExpressionContext ruleExpression(int i) {
			return GetRuleContext<RuleExpressionContext>(i);
		}
		public RuleExpression_AlternativesContext(RuleExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleExpression_Alternatives(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RuleExpressionContext ruleExpression() {
		return ruleExpression(0);
	}

	private RuleExpressionContext ruleExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		RuleExpressionContext _localctx = new RuleExpressionContext(Context, _parentState);
		RuleExpressionContext _prevctx = _localctx;
		int _startState = 26;
		EnterRecursionRule(_localctx, 26, RULE_ruleExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new RuleExpression_SequenceContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 163;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 162; ruleAtom();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 165;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,23,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
			Context.Stop = TokenStream.Lt(-1);
			State = 176;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new RuleExpression_AlternativesContext(new RuleExpressionContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_ruleExpression);
					State = 167;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 170;
					ErrorHandler.Sync(this);
					_alt = 1;
					do {
						switch (_alt) {
						case 1:
							{
							{
							State = 168; Match(T__14);
							State = 169; ruleExpression(0);
							}
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 172;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,24,Context);
					} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
					}
					} 
				}
				State = 178;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class SettingsContext : ParserRuleContext {
		public SettingContext[] setting() {
			return GetRuleContexts<SettingContext>();
		}
		public SettingContext setting(int i) {
			return GetRuleContext<SettingContext>(i);
		}
		public SettingsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_settings; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSettings(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SettingsContext settings() {
		SettingsContext _localctx = new SettingsContext(Context, State);
		EnterRule(_localctx, 28, RULE_settings);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 179; setting();
			State = 184;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==T__4) {
				{
				{
				State = 180; Match(T__4);
				State = 181; setting();
				}
				}
				State = 186;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SettingContext : ParserRuleContext {
		public SettingContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setting; } }
	 
		public SettingContext() { }
		public virtual void CopyFrom(SettingContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Setting_FlagContext : SettingContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Setting_FlagContext(SettingContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetting_Flag(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Setting_ValueContext : SettingContext {
		public IdContext[] id() {
			return GetRuleContexts<IdContext>();
		}
		public IdContext id(int i) {
			return GetRuleContext<IdContext>(i);
		}
		public Setting_ValueContext(SettingContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetting_Value(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SettingContext setting() {
		SettingContext _localctx = new SettingContext(Context, State);
		EnterRule(_localctx, 30, RULE_setting);
		try {
			State = 192;
			switch ( Interpreter.AdaptivePredict(TokenStream,27,Context) ) {
			case 1:
				_localctx = new Setting_FlagContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 187; id();
				}
				break;
			case 2:
				_localctx = new Setting_ValueContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 188; id();
				State = 189; Match(T__19);
				State = 190; id();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TokenReferenceContext : ParserRuleContext {
		public ITerminalNode TOKEN_ID() { return GetToken(DOMEParser.TOKEN_ID, 0); }
		public TokenReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tokenReference; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokenReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TokenReferenceContext tokenReference() {
		TokenReferenceContext _localctx = new TokenReferenceContext(Context, State);
		EnterRule(_localctx, 32, RULE_tokenReference);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 194; Match(TOKEN_ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TokenDefinitionContext : ParserRuleContext {
		public ITerminalNode TOKEN_ID() { return GetToken(DOMEParser.TOKEN_ID, 0); }
		public TokenAtomContext tokenAtom() {
			return GetRuleContext<TokenAtomContext>(0);
		}
		public InfoContext info() {
			return GetRuleContext<InfoContext>(0);
		}
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public TokenDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tokenDefinition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokenDefinition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TokenDefinitionContext tokenDefinition() {
		TokenDefinitionContext _localctx = new TokenDefinitionContext(Context, State);
		EnterRule(_localctx, 34, RULE_tokenDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 196; Match(TOKEN_ID);
			State = 198;
			_la = TokenStream.La(1);
			if (_la==T__7) {
				{
				State = 197; info();
				}
			}

			State = 200; Match(T__12);
			State = 201; tokenAtom(0);
			State = 204;
			_la = TokenStream.La(1);
			if (_la==T__20) {
				{
				State = 202; Match(T__20);
				State = 203; id();
				}
			}

			State = 206; Match(T__2);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TokenAtomContext : ParserRuleContext {
		public TokenAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tokenAtom; } }
	 
		public TokenAtomContext() { }
		public virtual void CopyFrom(TokenAtomContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TokenAtomTokenReferenceContext : TokenAtomContext {
		public TokenReferenceContext tokenReference() {
			return GetRuleContext<TokenReferenceContext>(0);
		}
		public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public InfoContext info() {
			return GetRuleContext<InfoContext>(0);
		}
		public TokenAtomTokenReferenceContext(TokenAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokenAtomTokenReference(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TokenAtomAlternativesContext : TokenAtomContext {
		public TokenAtomContext[] tokenAtom() {
			return GetRuleContexts<TokenAtomContext>();
		}
		public TokenAtomContext tokenAtom(int i) {
			return GetRuleContext<TokenAtomContext>(i);
		}
		public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public TokenAtomAlternativesContext(TokenAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokenAtomAlternatives(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TokenAtomPeriodContext : TokenAtomContext {
		public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public TokenAtomPeriodContext(TokenAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokenAtomPeriod(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TokenAtomLiteralContext : TokenAtomContext {
		public ITerminalNode LITERAL_STRING() { return GetToken(DOMEParser.LITERAL_STRING, 0); }
		public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public TokenAtomLiteralContext(TokenAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokenAtomLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TokenAtomInfoGroupContext : TokenAtomContext {
		public TokenAtomContext tokenAtom() {
			return GetRuleContext<TokenAtomContext>(0);
		}
		public InfoContext info() {
			return GetRuleContext<InfoContext>(0);
		}
		public TokenAtomInfoGroupContext(TokenAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokenAtomInfoGroup(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TokenAtomGroupContext : TokenAtomContext {
		public TokenAtomContext tokenAtom() {
			return GetRuleContext<TokenAtomContext>(0);
		}
		public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public TokenAtomGroupContext(TokenAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokenAtomGroup(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TokenAtomSequenceContext : TokenAtomContext {
		public TokenAtomContext[] tokenAtom() {
			return GetRuleContexts<TokenAtomContext>();
		}
		public TokenAtomContext tokenAtom(int i) {
			return GetRuleContext<TokenAtomContext>(i);
		}
		public TokenAtomSequenceContext(TokenAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokenAtomSequence(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TokenAtomClassContext : TokenAtomContext {
		public ITerminalNode LITERAL_CLASS() { return GetToken(DOMEParser.LITERAL_CLASS, 0); }
		public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public TokenAtomClassContext(TokenAtomContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IDOMEVisitor<TResult> typedVisitor = visitor as IDOMEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokenAtomClass(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TokenAtomContext tokenAtom() {
		return tokenAtom(0);
	}

	private TokenAtomContext tokenAtom(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		TokenAtomContext _localctx = new TokenAtomContext(Context, _parentState);
		TokenAtomContext _prevctx = _localctx;
		int _startState = 36;
		EnterRecursionRule(_localctx, 36, RULE_tokenAtom, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 252;
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				{
				_localctx = new TokenAtomLiteralContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 209; Match(LITERAL_STRING);
				State = 211;
				switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
				case 1:
					{
					State = 210; quantifier();
					}
					break;
				}
				}
				break;
			case 2:
				{
				_localctx = new TokenAtomClassContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 213; Match(LITERAL_CLASS);
				State = 215;
				switch ( Interpreter.AdaptivePredict(TokenStream,31,Context) ) {
				case 1:
					{
					State = 214; quantifier();
					}
					break;
				}
				}
				break;
			case 3:
				{
				_localctx = new TokenAtomPeriodContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 217; Match(T__21);
				State = 219;
				switch ( Interpreter.AdaptivePredict(TokenStream,32,Context) ) {
				case 1:
					{
					State = 218; quantifier();
					}
					break;
				}
				}
				break;
			case 4:
				{
				_localctx = new TokenAtomTokenReferenceContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 221; tokenReference();
				State = 223;
				switch ( Interpreter.AdaptivePredict(TokenStream,33,Context) ) {
				case 1:
					{
					State = 222; quantifier();
					}
					break;
				}
				State = 226;
				switch ( Interpreter.AdaptivePredict(TokenStream,34,Context) ) {
				case 1:
					{
					State = 225; info();
					}
					break;
				}
				}
				break;
			case 5:
				{
				_localctx = new TokenAtomGroupContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 228; Match(T__15);
				State = 229; tokenAtom(0);
				State = 230; Match(T__16);
				State = 232;
				switch ( Interpreter.AdaptivePredict(TokenStream,35,Context) ) {
				case 1:
					{
					State = 231; quantifier();
					}
					break;
				}
				}
				break;
			case 6:
				{
				_localctx = new TokenAtomAlternativesContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 234; Match(T__15);
				State = 235; tokenAtom(0);
				State = 238;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				do {
					{
					{
					State = 236; Match(T__14);
					State = 237; tokenAtom(0);
					}
					}
					State = 240;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				} while ( _la==T__14 );
				State = 242; Match(T__16);
				State = 244;
				switch ( Interpreter.AdaptivePredict(TokenStream,37,Context) ) {
				case 1:
					{
					State = 243; quantifier();
					}
					break;
				}
				}
				break;
			case 7:
				{
				_localctx = new TokenAtomInfoGroupContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 246; Match(T__17);
				State = 247; tokenAtom(0);
				State = 248; Match(T__18);
				State = 250;
				switch ( Interpreter.AdaptivePredict(TokenStream,38,Context) ) {
				case 1:
					{
					State = 249; info();
					}
					break;
				}
				}
				break;
			}
			Context.Stop = TokenStream.Lt(-1);
			State = 262;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,41,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new TokenAtomSequenceContext(new TokenAtomContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_tokenAtom);
					State = 254;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 256;
					ErrorHandler.Sync(this);
					_alt = 1;
					do {
						switch (_alt) {
						case 1:
							{
							{
							State = 255; tokenAtom(0);
							}
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 258;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,40,Context);
					} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
					}
					} 
				}
				State = 264;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,41,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 13: return ruleExpression_sempred((RuleExpressionContext)_localctx, predIndex);
		case 18: return tokenAtom_sempred((TokenAtomContext)_localctx, predIndex);
		}
		return true;
	}
	private bool ruleExpression_sempred(RuleExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 1);
		}
		return true;
	}
	private bool tokenAtom_sempred(TokenAtomContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(Context, 2);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x1D\x10C\x4\x2\t"+
		"\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t"+
		"\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x3\x2\x3\x2"+
		"\x5\x2+\n\x2\x3\x2\a\x2.\n\x2\f\x2\xE\x2\x31\v\x2\x3\x3\x3\x3\x3\x3\x3"+
		"\x3\x5\x3\x37\n\x3\x3\x4\x5\x4:\n\x4\x3\x4\x3\x4\x5\x4>\n\x4\x3\x5\x5"+
		"\x5\x41\n\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x6\x3\x6\x3\x6\x3\x6\a\x6K\n\x6"+
		"\f\x6\xE\x6N\v\x6\x3\x6\x3\x6\x3\a\x3\a\x5\aT\n\a\x3\b\x3\b\x3\b\x3\b"+
		"\x3\t\x3\t\x3\t\x5\t]\n\t\x3\t\x3\t\x5\t\x61\n\t\x5\t\x63\n\t\x3\n\x3"+
		"\n\x3\v\x3\v\x5\vi\n\v\x3\v\x3\v\x3\v\x3\v\x3\f\x3\f\x3\f\x3\f\x5\fs\n"+
		"\f\x3\r\x3\r\x5\rw\n\r\x3\r\x3\r\x3\r\x3\r\a\r}\n\r\f\r\xE\r\x80\v\r\x3"+
		"\r\x3\r\x3\xE\x3\xE\x5\xE\x86\n\xE\x3\xE\x3\xE\x5\xE\x8A\n\xE\x3\xE\x5"+
		"\xE\x8D\n\xE\x3\xE\x3\xE\x5\xE\x91\n\xE\x3\xE\x5\xE\x94\n\xE\x3\xE\x3"+
		"\xE\x3\xE\x3\xE\x5\xE\x9A\n\xE\x3\xE\x3\xE\x3\xE\x3\xE\x5\xE\xA0\n\xE"+
		"\x5\xE\xA2\n\xE\x3\xF\x3\xF\x6\xF\xA6\n\xF\r\xF\xE\xF\xA7\x3\xF\x3\xF"+
		"\x3\xF\x6\xF\xAD\n\xF\r\xF\xE\xF\xAE\a\xF\xB1\n\xF\f\xF\xE\xF\xB4\v\xF"+
		"\x3\x10\x3\x10\x3\x10\a\x10\xB9\n\x10\f\x10\xE\x10\xBC\v\x10\x3\x11\x3"+
		"\x11\x3\x11\x3\x11\x3\x11\x5\x11\xC3\n\x11\x3\x12\x3\x12\x3\x13\x3\x13"+
		"\x5\x13\xC9\n\x13\x3\x13\x3\x13\x3\x13\x3\x13\x5\x13\xCF\n\x13\x3\x13"+
		"\x3\x13\x3\x14\x3\x14\x3\x14\x5\x14\xD6\n\x14\x3\x14\x3\x14\x5\x14\xDA"+
		"\n\x14\x3\x14\x3\x14\x5\x14\xDE\n\x14\x3\x14\x3\x14\x5\x14\xE2\n\x14\x3"+
		"\x14\x5\x14\xE5\n\x14\x3\x14\x3\x14\x3\x14\x3\x14\x5\x14\xEB\n\x14\x3"+
		"\x14\x3\x14\x3\x14\x3\x14\x6\x14\xF1\n\x14\r\x14\xE\x14\xF2\x3\x14\x3"+
		"\x14\x5\x14\xF7\n\x14\x3\x14\x3\x14\x3\x14\x3\x14\x5\x14\xFD\n\x14\x5"+
		"\x14\xFF\n\x14\x3\x14\x3\x14\x6\x14\x103\n\x14\r\x14\xE\x14\x104\a\x14"+
		"\x107\n\x14\f\x14\xE\x14\x10A\v\x14\x3\x14\x2\x4\x1C&\x15\x2\x4\x6\b\n"+
		"\f\xE\x10\x12\x14\x16\x18\x1A\x1C\x1E \"$&\x2\x2\x12D\x2(\x3\x2\x2\x2"+
		"\x4\x36\x3\x2\x2\x2\x6=\x3\x2\x2\x2\b@\x3\x2\x2\x2\n\x46\x3\x2\x2\x2\f"+
		"S\x3\x2\x2\x2\xEU\x3\x2\x2\x2\x10\x62\x3\x2\x2\x2\x12\x64\x3\x2\x2\x2"+
		"\x14\x66\x3\x2\x2\x2\x16n\x3\x2\x2\x2\x18t\x3\x2\x2\x2\x1A\xA1\x3\x2\x2"+
		"\x2\x1C\xA3\x3\x2\x2\x2\x1E\xB5\x3\x2\x2\x2 \xC2\x3\x2\x2\x2\"\xC4\x3"+
		"\x2\x2\x2$\xC6\x3\x2\x2\x2&\xFE\x3\x2\x2\x2(*\x5\b\x5\x2)+\x5\n\x6\x2"+
		"*)\x3\x2\x2\x2*+\x3\x2\x2\x2+/\x3\x2\x2\x2,.\x5\x4\x3\x2-,\x3\x2\x2\x2"+
		".\x31\x3\x2\x2\x2/-\x3\x2\x2\x2/\x30\x3\x2\x2\x2\x30\x3\x3\x2\x2\x2\x31"+
		"/\x3\x2\x2\x2\x32\x37\x5\x14\v\x2\x33\x37\x5\x16\f\x2\x34\x37\x5\x18\r"+
		"\x2\x35\x37\x5$\x13\x2\x36\x32\x3\x2\x2\x2\x36\x33\x3\x2\x2\x2\x36\x34"+
		"\x3\x2\x2\x2\x36\x35\x3\x2\x2\x2\x37\x5\x3\x2\x2\x2\x38:\a\x3\x2\x2\x39"+
		"\x38\x3\x2\x2\x2\x39:\x3\x2\x2\x2:;\x3\x2\x2\x2;>\a\x1B\x2\x2<>\a\x1C"+
		"\x2\x2=\x39\x3\x2\x2\x2=<\x3\x2\x2\x2>\a\x3\x2\x2\x2?\x41\x5\f\a\x2@?"+
		"\x3\x2\x2\x2@\x41\x3\x2\x2\x2\x41\x42\x3\x2\x2\x2\x42\x43\a\x4\x2\x2\x43"+
		"\x44\x5\x6\x4\x2\x44\x45\a\x5\x2\x2\x45\t\x3\x2\x2\x2\x46G\a\x6\x2\x2"+
		"GL\x5\x6\x4\x2HI\a\a\x2\x2IK\x5\x6\x4\x2JH\x3\x2\x2\x2KN\x3\x2\x2\x2L"+
		"J\x3\x2\x2\x2LM\x3\x2\x2\x2MO\x3\x2\x2\x2NL\x3\x2\x2\x2OP\a\x5\x2\x2P"+
		"\v\x3\x2\x2\x2QT\a\b\x2\x2RT\a\t\x2\x2SQ\x3\x2\x2\x2SR\x3\x2\x2\x2T\r"+
		"\x3\x2\x2\x2UV\a\n\x2\x2VW\x5\x1E\x10\x2WX\a\v\x2\x2X\xF\x3\x2\x2\x2Y"+
		"\x63\a\f\x2\x2Z\\\a\r\x2\x2[]\a\f\x2\x2\\[\x3\x2\x2\x2\\]\x3\x2\x2\x2"+
		"]\x63\x3\x2\x2\x2^`\a\xE\x2\x2_\x61\a\f\x2\x2`_\x3\x2\x2\x2`\x61\x3\x2"+
		"\x2\x2\x61\x63\x3\x2\x2\x2\x62Y\x3\x2\x2\x2\x62Z\x3\x2\x2\x2\x62^\x3\x2"+
		"\x2\x2\x63\x11\x3\x2\x2\x2\x64\x65\a\x1B\x2\x2\x65\x13\x3\x2\x2\x2\x66"+
		"h\a\x1B\x2\x2gi\x5\xE\b\x2hg\x3\x2\x2\x2hi\x3\x2\x2\x2ij\x3\x2\x2\x2j"+
		"k\a\xF\x2\x2kl\x5\x1C\xF\x2lm\a\x5\x2\x2m\x15\x3\x2\x2\x2no\x5\x1C\xF"+
		"\x2op\a\x10\x2\x2pr\a\x1B\x2\x2qs\x5\xE\b\x2rq\x3\x2\x2\x2rs\x3\x2\x2"+
		"\x2s\x17\x3\x2\x2\x2tv\a\x1B\x2\x2uw\x5\xE\b\x2vu\x3\x2\x2\x2vw\x3\x2"+
		"\x2\x2wx\x3\x2\x2\x2xy\a\xF\x2\x2y~\x5\x16\f\x2z{\a\x11\x2\x2{}\x5\x16"+
		"\f\x2|z\x3\x2\x2\x2}\x80\x3\x2\x2\x2~|\x3\x2\x2\x2~\x7F\x3\x2\x2\x2\x7F"+
		"\x81\x3\x2\x2\x2\x80~\x3\x2\x2\x2\x81\x82\a\x5\x2\x2\x82\x19\x3\x2\x2"+
		"\x2\x83\x85\a\x19\x2\x2\x84\x86\x5\x10\t\x2\x85\x84\x3\x2\x2\x2\x85\x86"+
		"\x3\x2\x2\x2\x86\xA2\x3\x2\x2\x2\x87\x89\x5\"\x12\x2\x88\x8A\x5\x10\t"+
		"\x2\x89\x88\x3\x2\x2\x2\x89\x8A\x3\x2\x2\x2\x8A\x8C\x3\x2\x2\x2\x8B\x8D"+
		"\x5\xE\b\x2\x8C\x8B\x3\x2\x2\x2\x8C\x8D\x3\x2\x2\x2\x8D\xA2\x3\x2\x2\x2"+
		"\x8E\x90\x5\x12\n\x2\x8F\x91\x5\x10\t\x2\x90\x8F\x3\x2\x2\x2\x90\x91\x3"+
		"\x2\x2\x2\x91\x93\x3\x2\x2\x2\x92\x94\x5\xE\b\x2\x93\x92\x3\x2\x2\x2\x93"+
		"\x94\x3\x2\x2\x2\x94\xA2\x3\x2\x2\x2\x95\x96\a\x12\x2\x2\x96\x97\x5\x1C"+
		"\xF\x2\x97\x99\a\x13\x2\x2\x98\x9A\x5\x10\t\x2\x99\x98\x3\x2\x2\x2\x99"+
		"\x9A\x3\x2\x2\x2\x9A\xA2\x3\x2\x2\x2\x9B\x9C\a\x14\x2\x2\x9C\x9D\x5\x1C"+
		"\xF\x2\x9D\x9F\a\x15\x2\x2\x9E\xA0\x5\xE\b\x2\x9F\x9E\x3\x2\x2\x2\x9F"+
		"\xA0\x3\x2\x2\x2\xA0\xA2\x3\x2\x2\x2\xA1\x83\x3\x2\x2\x2\xA1\x87\x3\x2"+
		"\x2\x2\xA1\x8E\x3\x2\x2\x2\xA1\x95\x3\x2\x2\x2\xA1\x9B\x3\x2\x2\x2\xA2"+
		"\x1B\x3\x2\x2\x2\xA3\xA5\b\xF\x1\x2\xA4\xA6\x5\x1A\xE\x2\xA5\xA4\x3\x2"+
		"\x2\x2\xA6\xA7\x3\x2\x2\x2\xA7\xA5\x3\x2\x2\x2\xA7\xA8\x3\x2\x2\x2\xA8"+
		"\xB2\x3\x2\x2\x2\xA9\xAC\f\x3\x2\x2\xAA\xAB\a\x11\x2\x2\xAB\xAD\x5\x1C"+
		"\xF\x2\xAC\xAA\x3\x2\x2\x2\xAD\xAE\x3\x2\x2\x2\xAE\xAC\x3\x2\x2\x2\xAE"+
		"\xAF\x3\x2\x2\x2\xAF\xB1\x3\x2\x2\x2\xB0\xA9\x3\x2\x2\x2\xB1\xB4\x3\x2"+
		"\x2\x2\xB2\xB0\x3\x2\x2\x2\xB2\xB3\x3\x2\x2\x2\xB3\x1D\x3\x2\x2\x2\xB4"+
		"\xB2\x3\x2\x2\x2\xB5\xBA\x5 \x11\x2\xB6\xB7\a\a\x2\x2\xB7\xB9\x5 \x11"+
		"\x2\xB8\xB6\x3\x2\x2\x2\xB9\xBC\x3\x2\x2\x2\xBA\xB8\x3\x2\x2\x2\xBA\xBB"+
		"\x3\x2\x2\x2\xBB\x1F\x3\x2\x2\x2\xBC\xBA\x3\x2\x2\x2\xBD\xC3\x5\x6\x4"+
		"\x2\xBE\xBF\x5\x6\x4\x2\xBF\xC0\a\x16\x2\x2\xC0\xC1\x5\x6\x4\x2\xC1\xC3"+
		"\x3\x2\x2\x2\xC2\xBD\x3\x2\x2\x2\xC2\xBE\x3\x2\x2\x2\xC3!\x3\x2\x2\x2"+
		"\xC4\xC5\a\x1C\x2\x2\xC5#\x3\x2\x2\x2\xC6\xC8\a\x1C\x2\x2\xC7\xC9\x5\xE"+
		"\b\x2\xC8\xC7\x3\x2\x2\x2\xC8\xC9\x3\x2\x2\x2\xC9\xCA\x3\x2\x2\x2\xCA"+
		"\xCB\a\xF\x2\x2\xCB\xCE\x5&\x14\x2\xCC\xCD\a\x17\x2\x2\xCD\xCF\x5\x6\x4"+
		"\x2\xCE\xCC\x3\x2\x2\x2\xCE\xCF\x3\x2\x2\x2\xCF\xD0\x3\x2\x2\x2\xD0\xD1"+
		"\a\x5\x2\x2\xD1%\x3\x2\x2\x2\xD2\xD3\b\x14\x1\x2\xD3\xD5\a\x19\x2\x2\xD4"+
		"\xD6\x5\x10\t\x2\xD5\xD4\x3\x2\x2\x2\xD5\xD6\x3\x2\x2\x2\xD6\xFF\x3\x2"+
		"\x2\x2\xD7\xD9\a\x1A\x2\x2\xD8\xDA\x5\x10\t\x2\xD9\xD8\x3\x2\x2\x2\xD9"+
		"\xDA\x3\x2\x2\x2\xDA\xFF\x3\x2\x2\x2\xDB\xDD\a\x18\x2\x2\xDC\xDE\x5\x10"+
		"\t\x2\xDD\xDC\x3\x2\x2\x2\xDD\xDE\x3\x2\x2\x2\xDE\xFF\x3\x2\x2\x2\xDF"+
		"\xE1\x5\"\x12\x2\xE0\xE2\x5\x10\t\x2\xE1\xE0\x3\x2\x2\x2\xE1\xE2\x3\x2"+
		"\x2\x2\xE2\xE4\x3\x2\x2\x2\xE3\xE5\x5\xE\b\x2\xE4\xE3\x3\x2\x2\x2\xE4"+
		"\xE5\x3\x2\x2\x2\xE5\xFF\x3\x2\x2\x2\xE6\xE7\a\x12\x2\x2\xE7\xE8\x5&\x14"+
		"\x2\xE8\xEA\a\x13\x2\x2\xE9\xEB\x5\x10\t\x2\xEA\xE9\x3\x2\x2\x2\xEA\xEB"+
		"\x3\x2\x2\x2\xEB\xFF\x3\x2\x2\x2\xEC\xED\a\x12\x2\x2\xED\xF0\x5&\x14\x2"+
		"\xEE\xEF\a\x11\x2\x2\xEF\xF1\x5&\x14\x2\xF0\xEE\x3\x2\x2\x2\xF1\xF2\x3"+
		"\x2\x2\x2\xF2\xF0\x3\x2\x2\x2\xF2\xF3\x3\x2\x2\x2\xF3\xF4\x3\x2\x2\x2"+
		"\xF4\xF6\a\x13\x2\x2\xF5\xF7\x5\x10\t\x2\xF6\xF5\x3\x2\x2\x2\xF6\xF7\x3"+
		"\x2\x2\x2\xF7\xFF\x3\x2\x2\x2\xF8\xF9\a\x14\x2\x2\xF9\xFA\x5&\x14\x2\xFA"+
		"\xFC\a\x15\x2\x2\xFB\xFD\x5\xE\b\x2\xFC\xFB\x3\x2\x2\x2\xFC\xFD\x3\x2"+
		"\x2\x2\xFD\xFF\x3\x2\x2\x2\xFE\xD2\x3\x2\x2\x2\xFE\xD7\x3\x2\x2\x2\xFE"+
		"\xDB\x3\x2\x2\x2\xFE\xDF\x3\x2\x2\x2\xFE\xE6\x3\x2\x2\x2\xFE\xEC\x3\x2"+
		"\x2\x2\xFE\xF8\x3\x2\x2\x2\xFF\x108\x3\x2\x2\x2\x100\x102\f\x4\x2\x2\x101"+
		"\x103\x5&\x14\x2\x102\x101\x3\x2\x2\x2\x103\x104\x3\x2\x2\x2\x104\x102"+
		"\x3\x2\x2\x2\x104\x105\x3\x2\x2\x2\x105\x107\x3\x2\x2\x2\x106\x100\x3"+
		"\x2\x2\x2\x107\x10A\x3\x2\x2\x2\x108\x106\x3\x2\x2\x2\x108\x109\x3\x2"+
		"\x2\x2\x109\'\x3\x2\x2\x2\x10A\x108\x3\x2\x2\x2,*/\x36\x39=@LS\\`\x62"+
		"hrv~\x85\x89\x8C\x90\x93\x99\x9F\xA1\xA7\xAE\xB2\xBA\xC2\xC8\xCE\xD5\xD9"+
		"\xDD\xE1\xE4\xEA\xF2\xF6\xFC\xFE\x104\x108";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
